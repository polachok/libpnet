// Copyright (c) 2014, 2015 Robert Clipsham <robert@octarineparrot.com>
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

use packet::Packet;
use packet::PrimitiveValues;
use packet::ip::IpNextHeaderProtocol;

use pnet_macros_support::types::*;

use std::net::{Ipv4Addr, Ipv6Addr};

/// Represents a TCP Packet
#[packet]
pub struct Tcp {
    source: u16be,
    destination: u16be,
    sequence: u32be,
    acknowledgement: u32be,
    data_offset: u4,
    reserved: u3,
    ns: u1,
    cwr: u1,
    ece: u1,
    urg: u1,
    ack: u1,
    psh: u1,
    rst: u1,
    syn: u1,
    fin: u1,
    window: u16be,
    checksum: u16be,
    urgent_ptr: u16be,
    #[length_fn = "tcp_options_length"]
    options: Vec<TcpOption>,
    #[payload]
    payload: Vec<u8>,
}

/// Represents a TCP option
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct TcpOptionNumber(pub u8);

/// TCP header options
#[allow(non_snake_case)]
#[allow(non_upper_case_globals)]
pub mod TcpOptionNumbers {
  use super::TcpOptionNumber;

  /// End of Options list
  pub const EOL: TcpOptionNumber = TcpOptionNumber(0);

  /// No operation
  pub const NOP: TcpOptionNumber = TcpOptionNumber(1);

  /// MSS
  pub const MSS: TcpOptionNumber = TcpOptionNumber(2);

  /// Window scale
  pub const WSCALE: TcpOptionNumber = TcpOptionNumber(3);

  /// Selective acknowledgements permitted
  pub const SACK_PERMITTED: TcpOptionNumber = TcpOptionNumber(4);

  /// Selective acknowledgment
  pub const SACK: TcpOptionNumber = TcpOptionNumber(5);

  /// Timestamps
  pub const TIMESTAMPS: TcpOptionNumber = TcpOptionNumber(8);
}

/// TCP option
#[packet]
pub struct TcpOption {
    #[construct_with(u8)]
    number: TcpOptionNumber,
    #[length_fn = "tcp_option_length"]
    // The length field is an optional field, using a Vec is a way to implement
    // it
    length: Vec<u8>,
    #[length_fn = "tcp_option_payload_length"]
    #[payload]
    data: Vec<u8>,
}

/// This function gets the 'length' of the length field of the IPv4Option packet
/// Few options (EOL, NOP) are 1 bytes long, and then have a length field equal
/// to 0
fn tcp_option_length(option: &TcpOptionPacket) -> usize {
    match option.get_number() {
        TcpOptionNumbers::EOL => 0,
        TcpOptionNumbers::NOP => 0,
        _ => 1,
    }
}

fn tcp_option_payload_length(ipv4_option: &TcpOptionPacket) -> usize {
    match ipv4_option.get_length().first() {
        Some(len) => *len as usize - 2,
        None => 0,
    }
}

impl TcpOptionNumber {
    /// Create a new TcpOptionNumber
    pub fn new(value: u8) -> TcpOptionNumber {
        TcpOptionNumber(value)
    }
}

impl PrimitiveValues for TcpOptionNumber {
    type T = (u8,);
    fn to_primitive_values(&self) -> (u8,) {
        (self.0,)
    }
}

fn tcp_options_length(tcp: &TcpPacket) -> usize {
  tcp.get_data_offset() as usize * 4 - 20
}
